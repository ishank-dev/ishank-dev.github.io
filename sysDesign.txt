
Set of questions

1. Caching the IDs
2. What type of caching, (distributed,local/global)
3. How many computers and location of datacenter (0,100000 ) (1000001, 2000000)

Functional Requirements
- ID should be unique (UUID)
- Usually primary keys or unique ids can identify a uniique post,picture or video

Non Functional Requirements
- reliable, should not generate unique ids
- it should be highly available


Two Approach
- Auto Increment // Does not scale well two systems can generate same key
- Date.now() // maintaining global clock not feasible 

// Feasible solution

1. Global Server Approach

Client 1 --- |
Client 2 --- Global ID Generator
Client 3 --- |

Drawbacks
- Single point of failure
- Too simple

2. Ticket Server Approach

Client 1
Client 2            DB1(), DB2
Client 3

Drawbacks
- The numbers generate are not easily sortable
- An additional piece you have added in your system now we have to scale it separately

3. Twitter/Snowflake Approach

64 bit id with a combination of 3ids
1. Time - 42 bits
2. Machine ID 10 bits 
3. Sequence Generator or local counter on each machine (12 bits)



Front End --> Backend Layer --> Storage <-- offline Transport Layer 
                                                                |

                                                             Analysis -> Results -> Backend Service -> FrontEnd



Twitter 

Requirements 

Functional requirements 
1. Follow functionality
2. Feed System (caching) 
3. Trending Tags 
4. Like, comment and retweet a tweet 
5. Each post will have a unique id (Ensuring unique id is generated at the same time)
6. Recommendation System (apriori algo , )

Non Functional Requirements 
- Caching, Loadbalancing and partitioning 

Extended Requirements 
- Click Stream Analysis, user data analytics etc 
- Third Party API 

Some Calculations 

    Number of users : 10 million
    Number of daily active users: 5 million 
    Number of daily active users tweeting: 1 million 
    Post: 200 kb (image)
    User_metadata = 100Kb
    Total Storage for 1 year = 10 million*100kb + 1 million *12*200 kbs = 34000000 kbs = 34 GBs 
    Request per second = 1M/60*60*24

API Design 
CRUD : user 
CRUD: post, comments 

Schema Design 

User -> id,name,email,followers
Post -> id, datePosted, likes,retweets, postedBy, retweettedBy,comments 

distributed System 

Client --> Cache --> Load Balancer --> API services (microservices) --> db (partitioning or sharding), filestorage

